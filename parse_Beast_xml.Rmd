---
title: "parse_Beast_xml.Rmd"
output: html_document
---

```{r}
library(xml2)
source("Functions.R") #I will use some functions I also use in the app
ebola_xml<-read_xml("input/ebola/Makona_1610_cds_ig.joint_GLM.xml")
#get the general linear model from the xml
ebola_glm_model<-xml_child(xml_child(ebola_xml, "glmSubstitutionModel"), "glmModel")

#distances matrices are in the first child design matrix
distance_matrices<-xml_child(xml_child(ebola_glm_model, 1), "designMatrix")

#the names for the states are in the transition matrices
transition_matrices<-xml_child(xml_child(ebola_glm_model, 2), "designMatrix")
```

```{r}
#transition matrices ####
transitions=data.frame()

#get the dimensions, of bidirectional transitions (to, from)
dimensions_states_bidirection<-as.numeric(xml_attrs(xml_child(xml_child(ebola_glm_model, 2), "parameter"))[["dimension"]])
for(i in 1:dimensions_states_bidirection){
  transitions[i,1]=xml_attrs(xml_child(transition_matrices, i))[["id"]]
}
colnames(transitions)=c("state")
names<-unlist(lapply(transitions$state, function(state) first.word(state, sep="_")))
names<-names[1:(length(names)/2)] #only take the first half of the names since we have "to" and "from"
names
```
```{r}
#distance matrix values ####
distances=data.frame()
dimensions_covariates<-xml_attrs(xml_child(xml_child(ebola_glm_model, 1), "parameter"))[["dimension"]]

for(i in 1:dimensions_covariates){
  distances[i,1]=xml_attrs(xml_child(distance_matrices, i))[["id"]]
  distances[i,2]=xml_attrs(xml_child(distance_matrices, i))[["value"]]
}
colnames(distances)=c("predictor", "values")
distances_final<-sapply(strsplit(distances$values, " "), function(x) na.omit(as.numeric(x)))
colnames(distances_final)=distances$predictor
head(distances_final)
```

```{r}
dimensions_states<-dimensions_states_bidirection/2
counter=0
apply(distances_final,2, function(predictor){
  counter<<-counter+1 #global variable is updated and so actually increased
  S<-diag(dimensions_states)
  S[upper.tri(S, diag=F)]<-predictor[1:(length(predictor)/2)]
  S[lower.tri(S, diag=F)]<-predictor[(length(predictor)/2+1):length(predictor)]
  S=t(S)
  diag(S)=rep(0, length(diag(S)))
  colnames(S)<-names
  rownames(S)<-names
  write.csv(S, file=paste0("input/ebola/tryout/",colnames(distances_final)[counter], ".csv"))
})
```


```{r}
##creating sampling locations from tree tips but removing all missing data tips since they will not be mapped ####
ebola<-read.beast("input/ebola/Makona_1610_cds_ig.GLM.MCC.tree")
tips<-getTipLabels(ebola)

missings<-c(which(as.vector(sapply(tips, function(x) str_split(x,"\\|")[[1]][5]))==""), 
            which(as.vector(sapply(tips, function(x) str_split(x,"\\|")[[1]][5]))=="?"),
            which(as.vector(sapply(tips, function(x) str_split(x,"\\|")[[1]][5]))=="WesternArea"))


ebola <-drop.tip(ebola,sort(missings, decreasing = T))
tips<-ebola@phylo[["tip.label"]]
sampling_locations<-as.vector(sapply(tips, function(x) str_split(x,"\\|")[[1]][5]))
write(sampling_locations, "input/ebola/tryout/ebola_sampling_locations.txt")
a<-read.table("input/ebola/tryout/ebola_sampling_locations.txt",blank.lines.skip = F)
write.beast(file = "input/ebola/tryout/ebola_no_missings", treedata = ebola)
df<-as_tibble(ebola)
sort(unique(sampling_locations))
names
unique(names[names %!in% sampling_locations])
unique(sampling_locations[sampling_locations %!in% names])
```

  