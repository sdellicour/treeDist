# Importing a distance Matrix --------------------------------------------------

#' #Importing a distance matrix
#' @param delimiter A optional value that can be passed to this function and is optional user input at the start of the app.
#' @param distances_raw_file The temp filename that is generated by shiny when the user selects a file on their computer.
#' @return The matrices in R matrix format, named.
importingDist<-function(distances_raw_file, delimiter){
  #In case the user did not enter a delimiter, then the function detect delimiter is called.
  if(input$delimiter==""){
    delimiter<-detect_delimiter(distances_raw_file)
  }
  distances_raw <- utils::read.csv(distances_raw_file, head=T, sep=delimiter)
  #Call to function reshape_Rownames
  distances_raw<-reshape_Rownames(distances_raw = distances_raw )
  distances_raw<-base::as.matrix(distances_raw)
  "distances_raw"=distances_raw
}

#' Detecting the delimiter is one of ",", "\t", ";", " ", "-", "_". Assumes a square matrix.
#' @param distances_raw_file The temp filename that is generated by shiny when the user selects a file on their computer. Here this variable is passed on from importingDist()
#' @return The delimiter that was detected.
detect_delimiter<-function(distances_raw_file){
  delimiters<-c(",", "\t", ";", " ", "-", "_")#if not one of these, then the method will fail, the user needs to specify uncommon delimiters
  for(delimiter_pre in delimiters){
    dim <- dim(read.csv(distances_raw_file, sep=delimiter_pre))
    if(dim[1]==(dim[2]-1) | dim[1]==(dim[2])){ #in case the matrix has a rownames column the number of cols can be equal or 1 less then number of rows
      delimiter<-delimiter_pre
      break
    }
  }
  "delimiter"=delimiter
}

#' This function is called from within importingDist() and checks whether the first entry in the first row and column is a number.
#' This function assumes, square matrices and numeric distances metrics.
#' @param distances_raw is a data.frame passed on from importingDist().
#' @return distances_raw with possibly first column removed and added as rownames.
reshape_Rownames<-function(distances_raw){
  if(!is.numeric(distances_raw[1,1])){
    rownames(distances_raw)=(distances_raw[,1])
    distances_raw=distances_raw[,2:length(distances_raw[1,])]#here we need to assume a square matrix to set the dimensions.
  }
  return(distances_raw)
}

# Import tree -------------------------------------------------------------

#TODO documentation
importingTree<-function(tree_file, file_type){
  print("Reading tree")
  switch(file_type,
         "nexus" = {
           tree <- ape::read.nexus(tree_file)
         },
         "newick" = {
           tree <- ape::read.tree(tree_file)
         },
         "beast" = {
           tree <- treeio::read.beast(tree_file)
           tree <- dplyr::as_tibble(tree)
           colnames(tree)[which(colnames(tree) == "branch.length")] <-"edge.length"
         })
  tree <- negativeBranchLength(tree)
  tree
}

importingSamplingLocations<-function(sampling_locations){
  tip_states <- utils::read.table(sampling_locations, blank.lines.skip = F)[,1]
  tip_states
}

#TODO documentation
negativeBranchLength<-function(tree){
  if(length(which(tree$edge.length<=0))>0){
    shiny::showNotification(
      ui=paste0("There were negative branch lenght in your tree, these were set to 1e-100. \n
                Running treeannotator with the option 'keep target heights' should avoid negative and 0 branch length." ),
      type = 'message',
      duration=30)
    tree$edge.length[which(tree$edge.length<0)]=1e-100    }
  return(tree)
}

#' Function that tries to guess the relevant annotation in the tree based on the distance matrices provided by the user. 
#' Function is only relevant in case tree was already annotated.
#' @param tree Tree in beast format 
#' @param distances_raw distance matrix in matrix format.
detectState<-function(tree, distances_raw){
  return()
}

GenerateRawTransitionMatrix = function(distances_raw, tree_df) {
  tip_states=colnames(distances_raw)
  transitions_raw= matrix(0, nrow=dim(distances_raw)[1], ncol=dim(distances_raw)[1])#0 matrix in size of distance matrix 
  row.names(transitions_raw) = tip_states
  colnames(transitions_raw) = tip_states
  tree_df<-tree_df
  for(node in tree_df$node){
    if(node!=tidytree::rootnode(tree_df)$node){
      parent_loc = get(state(), tidytree::parent(tree_df,node))
      if(is.list(parent_loc)) parent_loc=parent_loc[[1]][1]
      parent_loc = stringr::str_split(parent_loc,"\\+")[[1]][1]
      parent_loc = stringr::str_split(parent_loc," ")[[1]][1]
      
      child_loc<-get(state(),tree_df[tree_df$node==node,])
      if(is.list(child_loc)) child_loc=child_loc[[1]][1]
      child_loc = stringr::str_split(child_loc,"\\+")[[1]][1]
      child_loc = stringr::str_split(child_loc," ")[[1]][1]
      transitions_raw[parent_loc, child_loc]=transitions_raw[parent_loc, child_loc]+1
    }
  } 
  "transitions_raw"=transitions_raw
}


makeSymmetric<-function(matrix){
  matrix_sym<-matrix
  for (i in 1:dim(matrix)[1]){
    for (j in 1:dim(matrix)[2]){
      matrix_sym[i, j] <- matrix[j, i] + matrix[i, j]
    }
  }
  matrix_sym
}

GenerateFinal_Transitions_Distances <- function(transitions_raw, distances_raw) {
  names_matrixes<-outer(X = colnames(transitions_raw),
                        Y = rownames(transitions_raw),
                        FUN = function(X,Y) paste(X,Y,sep="->"))#all combination of transitions
  
  if(input$Symmetrie==TRUE){
    transitions<-makeSymmetric(transitions_raw)
    names_matrixes = names_matrixes[lower.tri(transitions)]#names and distance call before call to transition
    
    distances = sapply(distances_raw, function(distances_raw) distances_raw[lower.tri(distances_raw,diag = F)])#names and distances call before transition otherwise transition has changed
    transitions = transitions[lower.tri(transitions)]
  }else{
    names_matrixes =names_matrixes[(lower.tri(names_matrixes) | upper.tri(names_matrixes))] #names and distance call before call to transition
    #only the diagonal is excluded otherwise we keep both directions
    distances = sapply(distances_raw, function(distances_raw) distances_raw[(lower.tri(distances_raw) |upper.tri(distances_raw))])
    #distances is a matrix with the columns representing each a distacne matrix
    transitions=transitions_raw[(lower.tri(transitions_raw) | upper.tri(transitions_raw))]
    #bring transitions in same format, 1 columns and each transition for 1 state to the other, bidirectional, in rows
  }
  colnames(distances)<-column_names()   #adding the names to cols
  transition_distances<-data.frame(Transitions=transitions, distances, Key=names_matrixes)
  #adding the transitions as a column, adding the row_names as an additional variable (needed for tooltip)
  rownames(transition_distances)<-names_matrixes #adding rownames, not strictly required but neat
  
  transition_distances=transition_distances[which(transitions!=0),] #remove transitions that did not occur
  transition_distances
}



'%!in%' <- function(x,y){
  !('%in%'(x,y))
}

first.word <- function(my.string, sep="\\."){
  base::strsplit(my.string, sep)[[1]][1]
}


# extracting the tip labels from the sub tree
getTipLabels<-function(tree){
  if (isS4(tree)) {
    tip_labels <- tree@phylo$tip.label
  } else {
    tip_labels <- tree$tip.label
  }
  return(tip_labels)
}


